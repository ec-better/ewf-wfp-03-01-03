#!/opt/anaconda/envs/env_ewf_wfp_03_01_03/bin/python
##########
# This node recieves each sub-tile in pickle format 
# containing 6 bands: 'NDVI', 'OGVI', 'OCTI', 'Land mask', 'Cloud mask', 'OGVI fail mask' 
# Smooth & gap-filters each subtile for NDVI, OGVI and OTCI 
# Saves the output NDVI, OGVI and OTCI subtiles  
import os
import sys
import string
import atexit

import cioppy 
ciop = cioppy.Cioppy()
    
# define the exit codes
SUCCESS = 0
ERR_RESOLUTION = 10
ERR_STAGEIN = 20
ERR_NO_OUTPUT = 30

# add a trap to exit gracefully
def clean_exit(exit_code):
    log_level = 'INFO'
    if exit_code != SUCCESS:
        log_level = 'ERROR'  
   
    msg = {SUCCESS: 'Processing successfully concluded',
           ERR_RESOLUTION: 'Could not resolve Sentinel-1 product enclosure',
           ERR_STAGEIN: 'Could not stage-in Sentinel-1 product', 
           ERR_NO_OUTPUT: "Missing output"
    }
 
    ciop.log(log_level, msg[exit_code])  

def main():
        
    ciop = cioppy.Cioppy()
    
    os.chdir(ciop.tmp_dir)
    delta_day = int(ciop.getparam('delta_time_output'))

    data_pipeline_parameters = dict()    
    data_pipeline_parameters['username'] = ciop.getparam('_T2Username')
    data_pipeline_parameters['api_key'] = ciop.getparam('_T2ApiKey')

    creds = '{}:{}'.format(data_pipeline_parameters['username'],
                           data_pipeline_parameters['api_key'])

   
    for input in sys.stdin:
        ciop.log('INFO', 'Processing tile {}'.format(input.rstrip()))
        
        local_subtile = ciop.copy(input.rstrip(),
                                  ciop.tmp_dir,
                                  extract=False)
        
        ciop.log('INFO', 'Processing local tile {}'.format(local_subtile))

        sub_tile = pd.read_pickle(local_subtile, 'gzip')


        ciop.log('INFO', 'Do something')
        
        # add processing steps
        
        ciop.log('INFO', 'Publish something')
        ciop.publish(output_name + '.tif', mode='silent')

try:
    main()
except SystemExit as e:
    if e.args[0]:
        clean_exit(e.args[0])
    raise
else:
    atexit.register(clean_exit, 0)
